<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Introdução a Julia | Simulação e Otimização de Processos</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="Introdução a Julia" />
<meta name="author" content="Tiago Santos" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Documentação oficial : https://docs.julialang.org/en/v0.6.4/" />
<meta property="og:description" content="Documentação oficial : https://docs.julialang.org/en/v0.6.4/" />
<link rel="canonical" href="http://localhost:4000/2018/09/19/introduction-to-julia.html" />
<meta property="og:url" content="http://localhost:4000/2018/09/19/introduction-to-julia.html" />
<meta property="og:site_name" content="Simulação e Otimização de Processos" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-09-19T00:00:00+01:00" />
<script type="application/ld+json">
{"headline":"Introdução a Julia","dateModified":"2018-09-19T00:00:00+01:00","datePublished":"2018-09-19T00:00:00+01:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/09/19/introduction-to-julia.html"},"url":"http://localhost:4000/2018/09/19/introduction-to-julia.html","author":{"@type":"Person","name":"Tiago Santos"},"description":"Documentação oficial : https://docs.julialang.org/en/v0.6.4/","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link rel="stylesheet" href="/assets/css/style.css?v=">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Simulação e Otimização de Processos</h1>
      <h2 class="project-tagline">Material de apoio das aulas de SOP</h2>
      
      
    </section>

    <section class="main-content">
      <a href="http://localhost:4000">Retomar à página inicial</a>

<h1>Introdução a Julia</h1>

<table>
  <tr>
    <td>Autor</td>
    <td>Tiago Santos</td>
  </tr>
  <tr>
    <td>e-mail</td>
    <td><i>tpd.santos@campus.fct.unl.pt</i></td>
  </tr>
  <tr>
    <td>Data Criação</td>
    <td>13-09-2018</td>
  </tr>
  <tr>
    <td>Data Atualização</td>
    <td>21-09-2018</td>
  </tr>
</table>

<hr>

<p><strong>Documentação oficial :</strong> <em>https://docs.julialang.org/en/v0.6.4/</em></p>

<p><em>Julia</em> é uma linguagem de programação recente, leve e <em>open-source</em>. Em muito poucas palavras, é uma espécie de junção entre <em>MatLab</em> e <em>Python</em>, juntando a facilidade de cálculo numérico do <em>MatLab</em> com a flexibilidade dos objetos de <em>Python</em>. Esta documentação não supõe bases nenhumas de programação, embora assuma bases de cálculo matricial.</p>

<h2 id="a-repl-read-eval-print-loop">A REPL (read-eval-print-loop)</h2>

<p>A REPL é a linha de comandos utilizada em <em>Julia</em>. Nesta linha de comandos é onde fazemos testes, corremos código em separado ou contido num ficheiro.</p>

<h2 id="variáveis">Variáveis</h2>

<p>O aspeto mais importante de qualquer linguagem de programação é a variável. Uma variável é algo que nos fornece a possibilidade de reutilizar pedaços de código de uma forma fácil, sejam esses pedaços uma simples linha de código ou 10000. No REPL, definir uma variável é tão simples quanto:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">variable</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Com esta variável definida, podemos fazer inúmeros cálculos com ela:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">variable</span> <span class="o">*</span> <span class="mi">2</span>
<span class="n">variable</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">variable</span> <span class="o">-</span> <span class="n">variable</span><span class="o">/</span><span class="mi">2</span>
</code></pre></div></div>

<p>Copiem para o REPL (uma linha de cada vez) e vejam os resultados. Como numa função matemática, as variáveis ajudam-nos a criar programas gerais, que se aplicam a vários casos, sem termos de reescrever os programas já feitos.</p>

<h2 id="recursividade">Recursividade</h2>

<p>A recursividade é algo muito importante em qualquer linguagem, dá-nos a possibilidade de correr algum código um determinado número de vezes sem termos de o repetir manualmente. Há duas maneiras fazer isto, dependendo dos nossos objetivos, que são os ciclos <em>for</em> e <em>while</em>.</p>

<h3 id="ciclo-for">Ciclo <em>for</em></h3>

<p>É o tipo de ciclo mais utilizado, pois é versátil, embora nem seja sempre o mais adequado. Um exemplo muito simples:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">3</span> 
    <span class="n">println</span><span class="x">(</span><span class="n">i</span><span class="x">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Neste caso, ao dizermos <code class="highlighter-rouge">for i = 1:1:3</code>, estamos a dizer que queremos que todo o código entre esta linha e <code class="highlighter-rouge">end</code> corra três vezes (<code class="highlighter-rouge">1:1:3</code> significa que a variável <code class="highlighter-rouge">i</code> irá do 1, de 1 em 1, até ao 3, ou seja, 1, 2 e 3. Se o passo for de 1 em 1, podem omitir o 1 do meio e escrever apenas <code class="highlighter-rouge">for i = 1:3</code>). A função <code class="highlighter-rouge">println</code> faz com que o que está dentro dos parênteses seja mostrado na linha de comandos. Este exemplo não faz nada de útil, por isso vejamos outro onde tentamos calcular a sequência de fibonacci:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number_of_calculations</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">first_term</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">second_term</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">number_of_calculations</span>
    <span class="n">fib</span> <span class="o">=</span> <span class="n">first_term</span> <span class="o">+</span> <span class="n">second_term</span>
    <span class="n">first_term</span> <span class="o">=</span> <span class="n">second_term</span>
    <span class="n">second_term</span> <span class="o">=</span> <span class="n">fib</span>
    <span class="n">println</span><span class="x">(</span><span class="n">fib</span><span class="x">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Com este código podemos ver os primeiros valores da sequência de fibonacci, principalmente os primeiros cinco (sem contar com os dois primeiros que são 1). A implementação de um ciclo <em>for</em> é extremamente simples e flexível, útil numa infinidade de casos.</p>

<h3 id="ciclo-while">Ciclo <em>while</em></h3>

<p>O ciclo <em>while</em> é outro exemplo de recursividade mais específico. Neste caso, em vez de especificarmos o número de vezes que se quer correr o código (no exemplo anterior, eram 5), temos de dizer quando é que queremos que <em>while</em> pare. Usaremos o exemplo anterior, mas em vez de um <em>for</em> utilizaremos um <em>while</em>. Para tentarmos replicar exatamente a mesma resposta, temos de saber qual o último valor determinado, que foi 13. Tendo em conta isso, vamos construir o ciclo:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">number_of_calculations</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">first_term</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">second_term</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">while</span> <span class="n">first_term</span><span class="o">+</span><span class="n">second_term</span> <span class="o">&lt;=</span> <span class="mi">13</span>
    <span class="n">fib</span> <span class="o">=</span> <span class="n">first_term</span> <span class="o">+</span> <span class="n">second_term</span>
    <span class="n">first_term</span> <span class="o">=</span> <span class="n">second_term</span>
    <span class="n">second_term</span> <span class="o">=</span> <span class="n">fib</span>
    <span class="n">println</span><span class="x">(</span><span class="n">fib</span><span class="x">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Deste modo conseguimos replicar o resultado usando outra forma de escrita. Para resolver este problema ambas as formas são igualmente boas, agora o uso de uma ou outra depende dos dados que pretendem introduzir (se o número de cálculos ou o valor final de cálculo) e do programador em si. Há casos em que uma ou outra são mais simples de utilizar, mas não é obrigatório que utilizem sempre a mais simples, utilizem a que gostam mais, desde que resulte (eu pessoalmente tento evitar os ciclos <em>while</em>, mas é a minha opinião pessoal).</p>

<h2 id="condições">Condições</h2>

<p>Esta é uma secção é importantíssima, pois não há forma de as escapar. Todo o programa acaba por precisar de tomar decisões, mas somos nós que temos de lhe indicar que decisões tomar.</p>

<p>No exemplo anterior do ciclo <em>while</em>, tivemos de tomar uma decisão, quando dizemos que queremos que o código pare de correr quando a condição <code class="highlighter-rouge">first_term+second_term &lt;= 13</code> é satisfeita. Se não a tomássemos, o programa correria infinitamente até o forçarmos a parar. Existem principalmente três tipos de cláusulas condicionais, a cláusula <code class="highlighter-rouge">case end</code>, <code class="highlighter-rouge">try catch end</code> e a <code class="highlighter-rouge">if elseif else end</code>. Vamo-nos focar apenas na última.</p>

<h3 id="cláusulas-if-elseif-else-end">Cláusulas <code class="highlighter-rouge">if elseif else end</code></h3>

<p>É impossível fugir a condições, e a mais versátil e simples é a cláusula <code class="highlighter-rouge">if</code>. Funciona praticamente como falamos, se aparecer “x” acontece “y”, senão acontece “z”. Em linguagem de programação ficaria algo assim:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">else</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Obviamente que isto é extremamente simples e não tem utilidade quase nenhuma na vida real, mas um exemplo simples é sempre o melhor para se entender os conceitos básicos.</p>

<p>Reparem que não há nenhum erro nas igualdades, ter <code class="highlighter-rouge">==</code> e <code class="highlighter-rouge">=</code> é diferente. <code class="highlighter-rouge">==</code> é usado para comparar e <code class="highlighter-rouge">=</code> é para definir uma variável. Por exemplo, <code class="highlighter-rouge">x == y</code> seria utilizado para comparar os valores de <code class="highlighter-rouge">x</code> e <code class="highlighter-rouge">y</code>, tendo como resultado verdadeiro ou falso, e <code class="highlighter-rouge">x = y</code> faz com que a variável <code class="highlighter-rouge">x</code> tenha o mesmo valor que <code class="highlighter-rouge">y</code>.</p>

<p>Agora vamos tentar fazer recriar o ciclo <em>while</em> feito anteriormente utilizando um ciclo <em>for</em> e uma cláusula <em>if</em>:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first_term</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">second_term</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="mi">10000</span>
    <span class="n">fib</span> <span class="o">=</span> <span class="n">second_term</span> <span class="o">+</span> <span class="n">first_term</span>
    <span class="n">first_term</span> <span class="o">=</span> <span class="n">second_term</span>
    <span class="n">second_term</span> <span class="o">=</span> <span class="n">fib</span>
    <span class="n">println</span><span class="x">(</span><span class="n">fib</span><span class="x">)</span>
    <span class="k">if</span> <span class="n">first_term</span><span class="o">+</span><span class="n">second_term</span> <span class="o">&gt;</span> <span class="mi">13</span>
        <span class="n">break</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Neste bocado já vemos várias coisas novas, por isso vê-las-emos uma a uma: logo na linha 4, <code class="highlighter-rouge">for i = 1:10000</code>, porquê um número tão grande? Obviamente era desnecessário, mas teoricamente não sabemos quantos ciclos são necessários para a condição que pusemos se satisfazer, por isso pus um número muito grande para ter a certeza que o ciclo não acaba antes da nossa condição ser satisfeita.</p>

<p>Na linha 8 temos a nossa condição, <code class="highlighter-rouge">if first_term+second_term &gt; 13</code>. O código entre o <code class="highlighter-rouge">if</code> e o <code class="highlighter-rouge">end</code> só é avaliado caso a nossa condição seja verdadeira. O <code class="highlighter-rouge">break</code> significa apenas que queremos forçar o ciclo <em>for</em> a acabar, não interessa se faltam ciclos ou não, obtendo-se assim o mesmo resultado dos anteriores exemplos.</p>

<h2 id="vetores">Vetores</h2>

<p>Outra das enormes potencialidades de uma linguagem de programação como <em>Julia</em> é a sua capacidade para trabalhar com vetores e matrizes. Continuando com o mesmo exemplo da sequência de fibonacci, não seria melhor, em vez de estarmos sempre a definir valores diferentes para as mesmas variáveis, guardar todos os valores num vetor? Uma sequência pode ser considerada um simples vetor, não? Vamos ver então:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fib</span> <span class="o">=</span> <span class="x">[</span><span class="mi">0</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span> <span class="c"># primeiro e segundo termos da sequência</span>

<span class="k">while</span> <span class="n">sum</span><span class="x">(</span><span class="n">fib</span><span class="x">[</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="k">end</span><span class="x">])</span> <span class="o">&lt;=</span> <span class="mi">13</span>
    <span class="n">push!</span><span class="x">(</span><span class="n">fib</span><span class="x">,</span><span class="n">sum</span><span class="x">(</span><span class="n">fib</span><span class="x">[</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="k">end</span><span class="x">]))</span>
<span class="k">end</span>
<span class="n">display</span><span class="x">(</span><span class="n">fib</span><span class="x">)</span>
</code></pre></div></div>

<p>Parece mais estranho, mas é muito mais conciso, para além de mais flexível. Usando vetores conseguimos reduzir o número de linhas de código e guardar os dados da sequência, no caso de precisarmos deles. Vamos então esmiufrar este bocado:</p>

<p>Na linha 1 definimos que a nossa variável <code class="highlighter-rouge">fib</code> é um vetor já com dois valores. O vetor mais simples é simplesmente <code class="highlighter-rouge">var = []</code> que define a variável como um vetor com zero entradas.</p>

<p>Na linha 3, na parte <code class="highlighter-rouge">fib[end-1:end]</code>, temos uma nova sintaxe, que é o que eu gosto de chamar em português de “fatiação”, a minha tradução literal do inglês <em>slicing</em>. Claro que esta palavra não existe (ou será que existe??) mas refere-se ao facto de podermos utilizar “fatias” de um vetor e criar outro. O que está dentro dos parênteses retos são índices das entradas do vetor, por exemplo, <code class="highlighter-rouge">fib[1]</code> dá-nos o valor 0 e fib[2] dá-nos o valor 1. A entrada <code class="highlighter-rouge">end</code> representa o índice da última entrada do vetor.</p>

<p>Na linha 4 temos uma nova função, a função <code class="highlighter-rouge">push!</code>. Esta função serve para adicionarmos elementos a um vetor existente. Se <code class="highlighter-rouge">var = [1,2,3]</code>, então <code class="highlighter-rouge">push!(var,4)</code> tem como resultado <code class="highlighter-rouge">[1,2,3,4]</code>. Sendo assim estamos a somar os dois últimos valores de <code class="highlighter-rouge">fib</code> e a adicionar o resultado a <code class="highlighter-rouge">fib</code>.</p>

<p><strong>NOTA:</strong> Para quem está familiarizado com <em>MatLab</em> e/ou <em>Python</em>, <em>Julia</em> tem uma pequena mas significativa diferença, quando se define um vetor ele vem em modo coluna e não em modo linha. Em <em>MatLab</em>, <code class="highlighter-rouge">[1,2,3] == [1 2 3]</code>, mas em <em>Julia</em> é diferente, porque o primeiro é uma coluna e o segundo é uma linha.</p>

<p>Podemos também resolver este problema com um ciclo <em>for</em>:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fib</span> <span class="o">=</span> <span class="x">[</span><span class="mi">0</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="mi">5</span>
    <span class="n">push!</span><span class="x">(</span><span class="n">fib</span><span class="x">,</span><span class="n">sum</span><span class="x">(</span><span class="n">fib</span><span class="x">[</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="k">end</span><span class="x">]))</span>
<span class="k">end</span>
<span class="n">display</span><span class="x">(</span><span class="n">fib</span><span class="x">)</span>
</code></pre></div></div>

<p>Usar vetores é uma arma muito poderosa, por isso sempre que possam utilizem, se acharem que for útil, obviamente.</p>

<h2 id="funções">Funções</h2>

<p>Este é o último capítulo antes de passarmos aos scripts, e que capítulo é este… Tudo é feito através de funções, funções são os que nos permitem reutilizar código, escrever algo uma vez e nunca mais precisar tocar nele, simplesmente enviar novos argumentos para dentro dela e ter diferentes respostas.</p>

<p>No último exemplo dado, se eu quisesse experimentar o mesmo código várias vezes, com diferentes números de ciclos, teria de copiar, colar no REPL e mudar <code class="highlighter-rouge">for i = 1:5</code> para <code class="highlighter-rouge">for i = 1:random_number</code>, e isso é tedioso e consome demasiado tempo. Se colocássemos esse código numa função seria tudo mais simples! Vamos ver:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> fibonacci</span><span class="x">(</span><span class="n">n</span><span class="x">)</span>
    <span class="n">fib</span> <span class="o">=</span> <span class="x">[</span><span class="mi">0</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
        <span class="n">push!</span><span class="x">(</span> <span class="n">fib</span> <span class="x">,</span> <span class="n">sum</span><span class="x">(</span> <span class="n">fib</span><span class="x">[</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="k">end</span><span class="x">]</span> <span class="x">)</span> <span class="x">)</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">fib</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Aqui temos várias coisas para detalhar:</p>

<p>Na linha 1, em <code class="highlighter-rouge">fibonacci(n)</code> definimos o nome da função (fibonacci) e o nome dos argumentos necessários passar à função para ela fazer o seu trabalho (neste caso é só necessário um, mas se fossem precisos mais bastava separá-los por vírgulas, por exemplo <code class="highlighter-rouge">function fibonacci(arg1,arg2,arg3) end</code>)</p>

<p>Na linha 6, a sintaxe <code class="highlighter-rouge">return fib</code> significa que a função, depois de fazer os cálculos, vai-nos devolver o vetor <code class="highlighter-rouge">fib</code>.</p>

<p>Neste caso, se quisermos fazer cinco cálculos, como nos exemplos anteriores, basta escrever no REPL <code class="highlighter-rouge">fibonacci(5)</code> e o mesmo resultado aparecer-vos-á.</p>

<p>Até agora nós temos descartado os primeiros dois valores da sequência, por exemplo, se queremos determinar cinco valores, na realidade estamos a determinar sete, visto que os dois primeiros são dados. Imaginando que o nosso objetivo é obter exatamente cinco valores da sequência, temos de alterar o exemplo anterior:</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> fibonacci</span><span class="x">(</span><span class="n">n</span><span class="x">)</span>
    <span class="n">fib</span> <span class="o">=</span> <span class="x">[</span><span class="mi">0</span><span class="x">,</span><span class="mi">1</span><span class="x">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">fib</span><span class="x">[</span><span class="mi">1</span><span class="x">]</span>
    <span class="k">elseif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">fib</span>
    <span class="k">else</span>
        <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span>
            <span class="n">push!</span><span class="x">(</span> <span class="n">fib</span> <span class="x">,</span> <span class="n">sum</span><span class="x">(</span><span class="n">fib</span><span class="x">[</span><span class="k">end</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span><span class="k">end</span><span class="x">])</span> <span class="x">)</span>
        <span class="k">end</span>
        <span class="k">return</span> <span class="n">fib</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Esta já é uma função mais complexa, onde está implementado tudo o que demos até agora, ciclos, condições, vetores e funções.</p>


<hr>

<a href="http://localhost:4000">Retomar à página inicial</a>


      <footer class="site-footer">
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>
    </section>

    
  </body>
</html>
