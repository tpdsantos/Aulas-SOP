<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-10-19T17:35:05+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Simulação e Otimização de Processos</title><subtitle>Material de apoio das aulas de SOP</subtitle><entry><title type="html">Desenvolver um solucionador de sudokus</title><link href="http://localhost:4000/2018/10/19/sudoku.html" rel="alternate" type="text/html" title="Desenvolver um solucionador de sudokus" /><published>2018-10-19T00:00:00+01:00</published><updated>2018-10-19T00:00:00+01:00</updated><id>http://localhost:4000/2018/10/19/sudoku</id><content type="html" xml:base="http://localhost:4000/2018/10/19/sudoku.html">&lt;p&gt;Nesta secção vamos aprender a formular um solucionador de sudokus, recorrendo a todas as ferramentas que já aprendemos de AMPL e mais algumas novas.&lt;/p&gt;

&lt;h2 id=&quot;introdução&quot;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Sudoku é um jogo baseado na colocação lógica de números. O objetivo do jogo é a colocação de números de 1 a 9 em cada uma das células vazias numa grelha de 9 × 9, constituída por 3 × 3 sub-grelhas chamadas regiões. O quebra-cabeça contém algumas pistas iniciais, que são números inseridos em algumas células, de maneira a permitir uma indução ou dedução dos números em células que estejam vazias. Cada coluna, linha e região só pode ter um número de cada um dos 1 a 9.&lt;/p&gt;

&lt;h2 id=&quot;resolução&quot;&gt;Resolução&lt;/h2&gt;

&lt;p&gt;Desde já começamos por criar os conjuntos de linhas e colunas do Sudoku:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set ROWS := 1..9 ;
set COLS := 1..9 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Em cada uma das células da grelha deverá colocar-se um número inteiro entre 1 e 9. Por uma questão de conveniência vamos exprimir o número \(n_{i,j}\) colocado na linha \(i\) e coluna \(j\) da seguinte forma:&lt;/p&gt;

&lt;p&gt;\[
n_{i,j} = 1 \times b_{i,j,1} + 2 \times b_{i,j,2} + … + 9 \times b_{i,j,9} = \sum_{k=1}^9 k \times b_{i,j,k} 
\]&lt;/p&gt;

&lt;p&gt;em que cada uma das variáveis \( b_{i,j,k} \in \{0,1\} \)  é binária, isto é, que só pode assumir um de dois valores: zero ou um. Obviamente, na expressão que define \( n_{i,j} \) só um dos \( b_{i,j,k} \) é que pode ser igual a 1 sendo todos os outros iguais a 0, ou seja, as variáveis binárias \( b_{i,j,k} \) têm de satisfazer a seguinte condição:&lt;/p&gt;

&lt;p&gt;\[
\sum_{k=1}^9 b_{i,j,k} = 1, \forall_i \in ROWS, \forall_j \in COLS
\]&lt;/p&gt;

&lt;p&gt;O equivalente em AMPL será:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set DIGITS := 1..9 ;

var b { ROWS, COLS, DIGITS } binary ;

var n { r in ROWS , c in COLS } = sum { d in DIGITS } ( d * b[r,c,d] ) ;

s.t. unique_digits { r in ROWS , c in COLS } : sum { d in DIGITS } ( b[r,c,d] ) = 1 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Agora consideremos as restantes condições do Sudoku. Comecemos pelas mais fáceis. Uma linha do Sudoku tem de conter os números de 1 a 9 sem repetição. Por exemplo, suponha-se que a quarta linha contêm a seguinte sequência válida de números de 1 a 9: 3, 5, 1, 8, 6, 7, 9, 2, 4. Os valores de \( b_{4,j,k} \) com \( j \in COLS, k \in DIGITS \) será:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  k= 1 2 3 4 5 6 7 8 9
  
j=1: 0 0 1 0 0 0 0 0 0

j=2: 0 0 0 0 0 0 0 1 0

j=3: 1 0 0 0 0 0 0 0 0

j=4: 0 0 0 0 0 0 0 0 1

j=5: 0 1 0 0 0 0 0 0 0

j=6: 0 0 0 0 1 0 0 0 0

j=7: 0 0 0 0 0 1 0 0 0

j=8: 0 0 0 1 0 0 0 0 0

j=9: 0 0 0 0 0 0 1 0 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Conclui-se que uma linha com sequência válida tem de satisfazer a seguinte condição:&lt;/p&gt;

&lt;p&gt;\[
\sum_{j \in COLS} d_{i,j,k} = 1, \forall_i \in LINES, \forall_k \in DIGITS
\]&lt;/p&gt;

&lt;p&gt;A restrição equivalente em AMPL será:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s.t. unique_rows { r in ROWS , d in DIGITS } : sum { c in COLS } ( b[r,c,d] ) = 1 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Se aplicarmos um raciocínio idêntico a uma coluna arbitrária chegamos a uma conclusão parecida, isto é,&lt;/p&gt;

&lt;p&gt;\[
\sum_{i \in ROWS} b_{i,j,k} = 1, \forall_j \in COLS, \forall_k \in DIGITS
\]&lt;/p&gt;

&lt;p&gt;A restrição equivalente em AMPL será:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s.t. unique_cols { r in ROWS , d in DIGITS } : sum { r in ROWS } ( b[i,j,k] ) = 1 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finalmente, a última condição é que o conjunto de números distribuídos em cada uma das nove regiões da grelha não pode conter elementos repetidos. Primeiramente precisamos de definir os elementos de cada região da grelha. Por exemplo, uma forma de enumerar os elementos de cada região será:&lt;/p&gt;

&lt;p&gt;\[
\{ (I+i,J+j) : i = 0,1,2 , j = 0,1,2 \}, \forall_I \in \{1,4,7\}, \forall_J \in \{1,4,7\}
\]&lt;/p&gt;

&lt;p&gt;De acordo com esta definição os elementos da região definida por \( I = 4 \), \( J = 7 \) serão (4,7), (4,8), (4,9), (5,7), (5,8), (5,9), (6,7), (6,8), (6,9), e assim por diante.&lt;/p&gt;

&lt;p&gt;A restrição em AMPL baseada nesta ordenação das regiões será:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s.t. sub_grid { I in {1,4,7}, J in {1,4,7}, d in DIGITS } : 
     sum { i in {0,1,2} , j in {0,1,2} } ( b[I+i,J+j,k] ) = 1 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finalmente, consideremos as pistas iniciais, que são números inseridos em algumas células, de maneira a permitir uma indução ou dedução dos números em células que estejam vazias. As pistas pertencem a um conjunto de pares \( (i,j,n_{ij}^0) \in ROWS \times COLS \times DIGITS \) que indicam que a célula com coordenadas \( (i,j) \) tem o número \( n_{ij}^0 \).&lt;/p&gt;

&lt;p&gt;Em AMPL podemos definir um conjuntos CLUES, a ser definido pelo utilizador, que contém as posições dos números conhecidos:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set CLUES within { ROWS , COLS } ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Esta definição obriga a que o conjunto CLUES seja um subconjunto do conjunto de todos os pares formados a partir de ROWS e COLS. Os números \( n_{ij}^0 \) são definidos como parâmetros a introduzir pelo utilizador:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;param n0 { CLUES } integer &amp;gt;= 1, &amp;lt;= 9 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Esta declaração obriga a que os valores de \( n_{ij}^0 \) sejam inteiros entre 1 e 9. Conhecidos os valores de \( n_{ij}^0 \) podemos fixar os valores correpondentes de \( b_{i,j,k} \) :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s.t. fix_vars { (i,j) in CLUES, d in DIGITS } :
     b[i,j,k] = (if n0[i,j] = k then 1 else 0) ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Para que as variáveis \( b \) fixadas por estas condições sejam automaticamente eliminadas do problema é necessário adicionar a seguinte opção:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;option substout 1 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Já agora, para que o AMPL seja mais descritivo na forma como simplifica o problema convém adicionar a seguinte opção:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;option show_stats 1 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;exemplo&quot;&gt;Exemplo&lt;/h2&gt;

&lt;p&gt;Na aula do dia 19-10-2018 foi realizado um exemplo. Foi-se buscar à internet um sudoku com os seguintes valores iniciais:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;C1&lt;/th&gt;
      &lt;th&gt;C2&lt;/th&gt;
      &lt;th&gt;C3&lt;/th&gt;
      &lt;th&gt;C4&lt;/th&gt;
      &lt;th&gt;C5&lt;/th&gt;
      &lt;th&gt;C6&lt;/th&gt;
      &lt;th&gt;C7&lt;/th&gt;
      &lt;th&gt;C8&lt;/th&gt;
      &lt;th&gt;C9&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;R1&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R2&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R5&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R6&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R7&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R8&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R9&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;No menu &lt;code class=&quot;highlighter-rouge&quot;&gt;data ;&lt;/code&gt; escrevemos estes dados da seguinte forma:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data ;

param: CLUES: n0 := 1 7 6
                    1 8 8
                    2 5 7
                    2 6 3
                    2 9 9
                    3 1 3
                    3 3 9
                    3 8 4
                    3 9 5
                    4 1 4
                    4 2 9
                    5 1 8
                    5 3 3
                    5 5 5
                    5 7 9
                    5 9 2
                    6 8 3
                    6 9 6
                    7 1 9
                    7 2 6
                    7 7 3
                    7 9 8
                    8 1 7
                    8 4 6
                    8 5 8
                    9 2 2
                    9 3 8 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Em cada tripla de valores, o primeiro é o número da linha, o segundo é o número da coluna e o terceiro é o valor do quadrado.&lt;/p&gt;

&lt;p&gt;Após explicitarmos os dados basta resolvermos mesmo o problema:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;option solver cplex ;

solve ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;e ver o nosso sudoku resolvido:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;display { r in ROWS, c in COLS } n[r,c] ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Assim termina esta secção.&lt;/p&gt;</content><author><name>José Paulo Mota</name></author><summary type="html">Nesta secção vamos aprender a formular um solucionador de sudokus, recorrendo a todas as ferramentas que já aprendemos de AMPL e mais algumas novas.</summary></entry><entry><title type="html">Formular um Problema</title><link href="http://localhost:4000/2018/10/06/problem-formulation.html" rel="alternate" type="text/html" title="Formular um Problema" /><published>2018-10-06T00:00:00+01:00</published><updated>2018-10-06T00:00:00+01:00</updated><id>http://localhost:4000/2018/10/06/problem-formulation</id><content type="html" xml:base="http://localhost:4000/2018/10/06/problem-formulation.html">&lt;p&gt;Nesta secção falaremos em como formular um problema real, criando restrições, variáveis dependentes e mandar o AMPL minimizar ou maximizar a condição desejada.&lt;/p&gt;

&lt;h2 id=&quot;variáveis-dependentes&quot;&gt;Variáveis dependentes&lt;/h2&gt;

&lt;p&gt;Na secção anterior aprendemos a declarar variáveis, mais especificamente variáveis independentes (VI). Variáveis dependentes (VD) e independentes funcionam exatamente da mesma forma que numa função. Uma VI é livremente modificada pelo AMPL para atingir o objetivo. Uma VD é dependente do valor das VI, sendo apenas modificada quando a VI é modificada. A sintaxe é muito simples, quase como escrever uma função:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dependent_var = ... 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Em que os &lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt; representam qualquer equação ou fórmula que dependa da/s VI.&lt;/p&gt;

&lt;p&gt;As VD servem principalmente para simplificar e tornar legível fórmulas e modelos mais complexos, com muitos termos e dependentes de muitas variáveis.&lt;/p&gt;

&lt;h2 id=&quot;restrições&quot;&gt;Restrições&lt;/h2&gt;

&lt;p&gt;As restrições são muito importantes em AMPL. Como o nome indica, são maneiras de escrever restriçṍes ao nosss problema, mas tem várias peculiaridades para nos facilitar a vida, por isso vamos abordar as mais usadas. A sintaxe mais simples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s.t. restriction_name : something = solmething_else ;
# or
subject to restriction_name : something = something_else ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;something&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;something_else&lt;/code&gt; podem ser qualquer tipo de fórmula ou equação, podem envolver VI, VD e parâmetros. Onde está &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; pode estar &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; &amp;gt; &amp;lt;= &amp;gt;=&lt;/code&gt;. Algo a notar é que, ao contrário de &lt;em&gt;Julia&lt;/em&gt;, o termo à esquerda do símbolo de comparação não é necessário que seja apenas uma variável, podemos ter expressões complexas em ambos os lados do símbolo.&lt;/p&gt;

&lt;p&gt;Muitas das vezes nós temos variáveis associadas a conjuntos, e normalmente queremos restrições para todas as associações das variáveis. Por exemplo, tendo um conjunto de matérias primas e tendo uma variável que é o caudal das matérias primas, queremos determinar o caudal ótimo de matérias primas sabendo que existe um limite máximo de venda de matérias primas por dia. Uma restrição que descreveria este exemplo seria:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set RAWMAT ;

var raw_flow { RAWMAT } ;

param raw_max { RAWMAT } ;

s.t. max_raw {r in RAWMAT} : raw_flow[r] &amp;lt;= raw_max[r] ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Com esta restrição estamos a construir uma espécie de ciclo &lt;em&gt;for&lt;/em&gt;, em que o &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; representa cada matéria prima.&lt;/p&gt;

&lt;h2 id=&quot;a-função-sum&quot;&gt;A função &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;A função &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt; é bastante importante e utilizada, por isso merece uma secção independente. Em muitos problemas de otimização precisamos de somar parâmetros, variáveis ou a junção dos dois. Vamos ver a sintaxe com um exemplo. Tendo em conta tudo o que vimos até agora, vamos acrescentar um parâmetro, a quantidade de quilos de cada matéria prima necessária para criar um quilo de produto, assumindo que só há um produto:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set RAWMAT ;

param FRAC_RAW { RAWMAT } &amp;gt;= 0 ;

var raw_flow { RAWMAT } &amp;gt;= 0 ;

var prod = sum {r in RAWMAT} ( FRAC_RAW[r] * raw_flow[r] ) ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A sintaxe de &lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt; é idêntica a todos os outros comandos: dentro das chavetas metemos o conjunto que queremos somar e à frente a expressão que cada valor, a somar, vai tomar.&lt;/p&gt;

&lt;h2 id=&quot;o-comando-maximize-e-minimize&quot;&gt;O comando &lt;code class=&quot;highlighter-rouge&quot;&gt;maximize&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;minimize&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Depois do problema ser formulado, precisamos de dizer ao AMPL o que otimizar. Queremos maximizar um lucro ou um rendimento? Queremos minimizar a soma dos erros quadráticos de uma experiência ou o tempo de operação de um processo? Podemos utilizar um dos dois comandos para fazer exatamente isso:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;maximize profit : sales - costs ;
# or
minimize square_errors : expression_to_be_minimized ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nestes comandos não se pode utilizar chavetas, só se pode dar expressões que dêm origem a um único valor.&lt;/p&gt;

&lt;p&gt;Na proxima secção falaremos como transmitir os dados específicos de cada problema para o AMPL.&lt;/p&gt;</content><author><name>Tiago Santos</name></author><summary type="html">Nesta secção falaremos em como formular um problema real, criando restrições, variáveis dependentes e mandar o AMPL minimizar ou maximizar a condição desejada.</summary></entry><entry><title type="html">Introdução a AMPL</title><link href="http://localhost:4000/2018/10/03/introduction-to-ampl.html" rel="alternate" type="text/html" title="Introdução a AMPL" /><published>2018-10-03T00:00:00+01:00</published><updated>2018-10-03T00:00:00+01:00</updated><id>http://localhost:4000/2018/10/03/introduction-to-ampl</id><content type="html" xml:base="http://localhost:4000/2018/10/03/introduction-to-ampl.html">&lt;h2 id=&quot;premissa-da-linguagem&quot;&gt;Premissa da linguagem&lt;/h2&gt;

&lt;p&gt;A linguagem AMPL é bastante distinta das outras linguagens mais populares no que toca à sua premissa principal. Ela não foi criada para ser flexível nem para ser versátil, foi criada para resolver um determinado tipo de problemas da forma mais eficiente e rápida possível, e faz exatamente isso, sacrificando a versatilidade.&lt;/p&gt;

&lt;p&gt;Tendo em conta isso, a linguagem AMPL foi criada especificamente para facilitar a formulação de problemas de otimização. Falando pessoalmente, acho que as pessoas sem conhecimentos de programação têm mais facilidade em adaptar-se à sintaxe, visto que é bastante diferente de todas as outras linguagens (eu, que quando aprendi vinha de MatLab, tive algumas dificuldades em percebê-la). Embora, no início, não pareça muito intuitiva, com um bocadinho de prática é muito fácil de se adaptar.&lt;/p&gt;

&lt;p&gt;Este tipo de linguagem não tem nada a ver com &lt;em&gt;MatLab&lt;/em&gt; nem &lt;em&gt;Python&lt;/em&gt;. Uma das pequenas coisas que têm em comum é o facto de podermos criar vetores. É uma linguagem baseada em conjuntos: quando criamos um conjunto, seja ele qual for (já mostraremos exemplos), ele podser atribuído a qualquer parâmetro ou variável criados. Uma outra grande diferença é o facto de ser &lt;strong&gt;100% declarativa&lt;/strong&gt;, o que significa que, antes de utilizarem uma variável ou um parâmetro quando estão a construir um modelo, essa variável ou parâmetro tem de ser explicitamente declarado, têm que dizer que é um parâmetro, a que conjunto pertence (pode ser a nenhum conjunto) e de que tipo (se são símbolos, números, etc). Não é possível criar variáveis intermediárias não declaradas.&lt;/p&gt;

&lt;p&gt;Outros dois pontos muito importantes são:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;todas as linhas de código têm de acabar com &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;. AMPL ignora todos os espaços em branco, temos de o informar especificamente que a nossa linha de código acabou.&lt;/li&gt;
  &lt;li&gt;devido ao ponto interior, a boa notícia é que podemos dividir linhas de código compridas (fórmulas complexas com muitos termos, por exemplo) por várias linhas, aumentando assim legibilidade dos nossos programas. Mais tarde veremos como tirar proveito dessa obrigatoriedade.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tomando isto em conta, vamos passar à prática:&lt;/p&gt;

&lt;h2 id=&quot;sintaxe-básica&quot;&gt;Sintaxe básica&lt;/h2&gt;

&lt;p&gt;Nesta secção falaremos nos elementos básicos de AMPL, como conjuntos, variáveis, parâmetros, fórmulas e restrições.&lt;/p&gt;

&lt;h3 id=&quot;conjuntos&quot;&gt;Conjuntos&lt;/h3&gt;

&lt;p&gt;Os conjuntos são a sintaxe mais geral e mais utilizada. Um conjunto não é nada mais do que uma sequência de valores para classificar algo. Por exemplo, se temos um problema de otimização em que queremos encontrar o caudal ótimo de entrada de matérias primas numa fábrica, tendo em conta os custos destas, por exemplo, criaríamos um conjunto com todas as matérias primas, como por exemplo:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set RAWMAT ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Desta forma criámos um conjunto, declarado pelo comando &lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;, chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;RAWMAT&lt;/code&gt; que engloba todas as matérias primas que entram na fábrica. Mais tarde daremos valores ao conjunto, por enquanto é geral. Deste modo podemos associar variáveis e/ou parâmetros a esse conjunto, para irmos construindo o problema. Se a ordem é importante, basta escrever &lt;code class=&quot;highlighter-rouge&quot;&gt;ordered&lt;/code&gt; à frente:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set RAWMAT ordered ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;variáveis&quot;&gt;Variáveis&lt;/h3&gt;

&lt;p&gt;Visto que queremos achar o caudal ótimo de matérias primas, temos de criar uma variável associada ao conjunto das matérias primas:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var raw_flow { RAWMAT } &amp;gt;= 0.0 ; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Nesta sintaxe temos várias nuances. O comando &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; serve para explicitar uma variável e o que está entre chavetas é o conjunto que queremos associar à variável. Não há limite para o número de associações, uma variável ou parâmetro pode estar associado a qualquer número de conjuntos. Suponhamos que cada matéria prima é vendida por fábricas diferentes, podemos fazer isto:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set RAWMAT ;
set FACTORIES ;

var raw_flow { RAWMAT, FACTORIES } &amp;gt;= 0 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Neste caso criámos uma variável associada a cada matéria prima e a cada fábrica. Outra maneira de explicar isto é pensando em matrizes: uma variável associada a dois conjuntos é idêntica a uma matriz com duas dimensões, em que cada fábrica (as colunas da matriz) vende todas as matérias primas (as linhas da matriz) necessárias à nossa fábrica, por exemplo. Ao escrevermos &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;= 0&lt;/code&gt; estamos apenas a dizer que a variável não pode tomar valores negativos.&lt;/p&gt;

&lt;h3 id=&quot;parâmetros&quot;&gt;Parâmetros&lt;/h3&gt;

&lt;p&gt;Parâmetros são constantes durante todo o programa. Podem ser rendimentos de reações, custos de matérias prima, custos de operação, etc. Para definir um basta:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;param RAW_COST { RAWMAT } &amp;gt;= 0 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Assim ficou definido um parâmetro que engloba os custos das matérias primas.&lt;/p&gt;

&lt;h3 id=&quot;tipos&quot;&gt;Tipos&lt;/h3&gt;

&lt;p&gt;A maior parte das variáveis e parâmetros são reais, podem tomar qualquer valor decimal. No entanto, algumas vezes queremos definir variáveis apenas como inteiras ou binárias. Para definirmos como inteiras:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var raw_flow { RAWMAT, FACTORIES } &amp;gt;= 0 integer ;
param RAW_COST { RAWMAT } &amp;gt;= 0 integer ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Assim estas instâncias apenas podem tomar valores inteiros.&lt;/p&gt;

&lt;p&gt;No caso de valores binários, quase sempre são utilizados apenas em variáveis, as chamadas variáveis de decisão. Suponhamos que temos vários equipamentos disponíveis numa fábrica, cada um com um tempo de trabalho e limpeza diferentes, com unidades em meses. Como maximizar o lucro anual sabendo que a disponibilidade dos equipamentos varia em cada mês? Com este problema podemos utilizar as variáveis binárias:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set EQUIPS ;
set MONTHS ;

var avail_equip { EQUIPS, MONTH } binary ; # avail de availability
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Desta forma podemos “ligar” e/ou “desligar” equipamentos em cada mês, visto que uma variável binária, como o nome indica, só pode tomar os valores 0 ou 1.&lt;/p&gt;

&lt;p&gt;Assim acaba esta secção. Na próxima falaremos em como criar um problema.&lt;/p&gt;</content><author><name>Tiago Santos</name></author><summary type="html">Premissa da linguagem</summary></entry><entry><title type="html">Introdução a Julia</title><link href="http://localhost:4000/2018/09/19/introduction-to-julia.html" rel="alternate" type="text/html" title="Introdução a Julia" /><published>2018-09-19T00:00:00+01:00</published><updated>2018-09-19T00:00:00+01:00</updated><id>http://localhost:4000/2018/09/19/introduction-to-julia</id><content type="html" xml:base="http://localhost:4000/2018/09/19/introduction-to-julia.html">&lt;p&gt;&lt;strong&gt;Documentação oficial :&lt;/strong&gt; &lt;em&gt;https://docs.julialang.org/en/v0.6.4/&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Julia&lt;/em&gt; é uma linguagem de programação recente, leve e &lt;em&gt;open-source&lt;/em&gt;. Em muito poucas palavras, é uma espécie de junção entre &lt;em&gt;MatLab&lt;/em&gt; e &lt;em&gt;Python&lt;/em&gt;, juntando a facilidade de cálculo numérico do &lt;em&gt;MatLab&lt;/em&gt; com a flexibilidade dos objetos de &lt;em&gt;Python&lt;/em&gt;. Esta documentação não supõe bases nenhumas de programação, embora assuma bases de cálculo matricial.&lt;/p&gt;

&lt;h2 id=&quot;a-repl-read-eval-print-loop&quot;&gt;A REPL (read-eval-print-loop)&lt;/h2&gt;

&lt;p&gt;A REPL é a linha de comandos utilizada em &lt;em&gt;Julia&lt;/em&gt;. Nesta linha de comandos é onde fazemos testes, corremos código em separado ou contido num ficheiro.&lt;/p&gt;

&lt;h2 id=&quot;variáveis&quot;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;O aspeto mais importante de qualquer linguagem de programação é a variável. Uma variável é algo que nos fornece a possibilidade de reutilizar pedaços de código de uma forma fácil, sejam esses pedaços uma simples linha de código ou 10000. No REPL, definir uma variável é tão simples quanto:&lt;/p&gt;

&lt;div class=&quot;language-julia highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Com esta variável definida, podemos fazer inúmeros cálculos com ela:&lt;/p&gt;

&lt;div class=&quot;language-julia highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Copiem para o REPL (uma linha de cada vez) e vejam os resultados. Como numa função matemática, as variáveis ajudam-nos a criar programas gerais, que se aplicam a vários casos, sem termos de reescrever os programas já feitos.&lt;/p&gt;

&lt;h2 id=&quot;recursividade&quot;&gt;Recursividade&lt;/h2&gt;

&lt;p&gt;A recursividade é algo muito importante em qualquer linguagem, dá-nos a possibilidade de correr algum código um determinado número de vezes sem termos de o repetir manualmente. Há duas maneiras fazer isto, dependendo dos nossos objetivos, que são os ciclos &lt;em&gt;for&lt;/em&gt; e &lt;em&gt;while&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;ciclo-for&quot;&gt;Ciclo &lt;em&gt;for&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;É o tipo de ciclo mais utilizado, pois é versátil, embora nem seja sempre o mais adequado. Um exemplo muito simples:&lt;/p&gt;

&lt;div class=&quot;language-julia highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Neste caso, ao dizermos &lt;code class=&quot;highlighter-rouge&quot;&gt;for i = 1:1:3&lt;/code&gt;, estamos a dizer que queremos que todo o código entre esta linha e &lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt; corra três vezes (&lt;code class=&quot;highlighter-rouge&quot;&gt;1:1:3&lt;/code&gt; significa que a variável &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; irá do 1, de 1 em 1, até ao 3, ou seja, 1, 2 e 3. Se o passo for de 1 em 1, podem omitir o 1 do meio e escrever apenas &lt;code class=&quot;highlighter-rouge&quot;&gt;for i = 1:3&lt;/code&gt;). A função &lt;code class=&quot;highlighter-rouge&quot;&gt;println&lt;/code&gt; faz com que o que está dentro dos parênteses seja mostrado na linha de comandos. Este exemplo não faz nada de útil, por isso vejamos outro onde tentamos calcular a sequência de fibonacci:&lt;/p&gt;

&lt;div class=&quot;language-julia highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;number_of_calculations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;first_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number_of_calculations&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;first_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Com este código podemos ver os primeiros valores da sequência de fibonacci, principalmente os primeiros cinco (sem contar com os dois primeiros que são 1). A implementação de um ciclo &lt;em&gt;for&lt;/em&gt; é extremamente simples e flexível, útil numa infinidade de casos.&lt;/p&gt;

&lt;h3 id=&quot;ciclo-while&quot;&gt;Ciclo &lt;em&gt;while&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;O ciclo &lt;em&gt;while&lt;/em&gt; é outro exemplo de recursividade mais específico. Neste caso, em vez de especificarmos o número de vezes que se quer correr o código (no exemplo anterior, eram 5), temos de dizer quando é que queremos que &lt;em&gt;while&lt;/em&gt; pare. Usaremos o exemplo anterior, mas em vez de um &lt;em&gt;for&lt;/em&gt; utilizaremos um &lt;em&gt;while&lt;/em&gt;. Para tentarmos replicar exatamente a mesma resposta, temos de saber qual o último valor determinado, que foi 13. Tendo em conta isso, vamos construir o ciclo:&lt;/p&gt;

&lt;div class=&quot;language-julia highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;number_of_calculations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;first_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_term&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;first_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Deste modo conseguimos replicar o resultado usando outra forma de escrita. Para resolver este problema ambas as formas são igualmente boas, agora o uso de uma ou outra depende dos dados que pretendem introduzir (se o número de cálculos ou o valor final de cálculo) e do programador em si. Há casos em que uma ou outra são mais simples de utilizar, mas não é obrigatório que utilizem sempre a mais simples, utilizem a que gostam mais, desde que resulte (eu pessoalmente tento evitar os ciclos &lt;em&gt;while&lt;/em&gt;, mas é a minha opinião pessoal).&lt;/p&gt;

&lt;h2 id=&quot;condições&quot;&gt;Condições&lt;/h2&gt;

&lt;p&gt;Esta é uma secção é importantíssima, pois não há forma de as escapar. Todo o programa acaba por precisar de tomar decisões, mas somos nós que temos de lhe indicar que decisões tomar.&lt;/p&gt;

&lt;p&gt;No exemplo anterior do ciclo &lt;em&gt;while&lt;/em&gt;, tivemos de tomar uma decisão, quando dizemos que queremos que o código pare de correr quando a condição &lt;code class=&quot;highlighter-rouge&quot;&gt;first_term+second_term &amp;lt;= 13&lt;/code&gt; é satisfeita. Se não a tomássemos, o programa correria infinitamente até o forçarmos a parar. Existem principalmente três tipos de cláusulas condicionais, a cláusula &lt;code class=&quot;highlighter-rouge&quot;&gt;case end&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;try catch end&lt;/code&gt; e a &lt;code class=&quot;highlighter-rouge&quot;&gt;if elseif else end&lt;/code&gt;. Vamo-nos focar apenas na última.&lt;/p&gt;

&lt;h3 id=&quot;cláusulas-if-elseif-else-end&quot;&gt;Cláusulas &lt;code class=&quot;highlighter-rouge&quot;&gt;if elseif else end&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;É impossível fugir a condições, e a mais versátil e simples é a cláusula &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;. Funciona praticamente como falamos, se aparecer “x” acontece “y”, senão acontece “z”. Em linguagem de programação ficaria algo assim:&lt;/p&gt;

&lt;div class=&quot;language-julia highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Obviamente que isto é extremamente simples e não tem utilidade quase nenhuma na vida real, mas um exemplo simples é sempre o melhor para se entender os conceitos básicos.&lt;/p&gt;

&lt;p&gt;Reparem que não há nenhum erro nas igualdades, ter &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; é diferente. &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt; é usado para comparar e &lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; é para definir uma variável. Por exemplo, &lt;code class=&quot;highlighter-rouge&quot;&gt;x == y&lt;/code&gt; seria utilizado para comparar os valores de &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;, tendo como resultado verdadeiro ou falso, e &lt;code class=&quot;highlighter-rouge&quot;&gt;x = y&lt;/code&gt; faz com que a variável &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; tenha o mesmo valor que &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Agora vamos tentar fazer recriar o ciclo &lt;em&gt;while&lt;/em&gt; feito anteriormente utilizando um ciclo &lt;em&gt;for&lt;/em&gt; e uma cláusula &lt;em&gt;if&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-julia highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;first_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_term&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;first_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_term&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second_term&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;break&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Neste bocado já vemos várias coisas novas, por isso vê-las-emos uma a uma: logo na linha 4, &lt;code class=&quot;highlighter-rouge&quot;&gt;for i = 1:10000&lt;/code&gt;, porquê um número tão grande? Obviamente era desnecessário, mas teoricamente não sabemos quantos ciclos são necessários para a condição que pusemos se satisfazer, por isso pus um número muito grande para ter a certeza que o ciclo não acaba antes da nossa condição ser satisfeita.&lt;/p&gt;

&lt;p&gt;Na linha 8 temos a nossa condição, &lt;code class=&quot;highlighter-rouge&quot;&gt;if first_term+second_term &amp;gt; 13&lt;/code&gt;. O código entre o &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; e o &lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt; só é avaliado caso a nossa condição seja verdadeira. O &lt;code class=&quot;highlighter-rouge&quot;&gt;break&lt;/code&gt; significa apenas que queremos forçar o ciclo &lt;em&gt;for&lt;/em&gt; a acabar, não interessa se faltam ciclos ou não, obtendo-se assim o mesmo resultado dos anteriores exemplos.&lt;/p&gt;

&lt;h2 id=&quot;vetores&quot;&gt;Vetores&lt;/h2&gt;

&lt;p&gt;Outra das enormes potencialidades de uma linguagem de programação como &lt;em&gt;Julia&lt;/em&gt; é a sua capacidade para trabalhar com vetores e matrizes. Continuando com o mesmo exemplo da sequência de fibonacci, não seria melhor, em vez de estarmos sempre a definir valores diferentes para as mesmas variáveis, guardar todos os valores num vetor? Uma sequência pode ser considerada um simples vetor, não? Vamos ver então:&lt;/p&gt;

&lt;div class=&quot;language-julia highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;x&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# primeiro e segundo termos da sequência&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;push!&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Parece mais estranho, mas é muito mais conciso, para além de mais flexível. Usando vetores conseguimos reduzir o número de linhas de código e guardar os dados da sequência, no caso de precisarmos deles. Vamos então esmiufrar este bocado:&lt;/p&gt;

&lt;p&gt;Na linha 1 definimos que a nossa variável &lt;code class=&quot;highlighter-rouge&quot;&gt;fib&lt;/code&gt; é um vetor já com dois valores. O vetor mais simples é simplesmente &lt;code class=&quot;highlighter-rouge&quot;&gt;var = []&lt;/code&gt; que define a variável como um vetor com zero entradas.&lt;/p&gt;

&lt;p&gt;Na linha 3, na parte &lt;code class=&quot;highlighter-rouge&quot;&gt;fib[end-1:end]&lt;/code&gt;, temos uma nova sintaxe, que é o que eu gosto de chamar em português de “fatiação”, a minha tradução literal do inglês &lt;em&gt;slicing&lt;/em&gt;. Claro que esta palavra não existe (ou será que existe??) mas refere-se ao facto de podermos utilizar “fatias” de um vetor e criar outro. O que está dentro dos parênteses retos são índices das entradas do vetor, por exemplo, &lt;code class=&quot;highlighter-rouge&quot;&gt;fib[1]&lt;/code&gt; dá-nos o valor 0 e fib[2] dá-nos o valor 1. A entrada &lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt; representa o índice da última entrada do vetor.&lt;/p&gt;

&lt;p&gt;Na linha 4 temos uma nova função, a função &lt;code class=&quot;highlighter-rouge&quot;&gt;push!&lt;/code&gt;. Esta função serve para adicionarmos elementos a um vetor existente. Se &lt;code class=&quot;highlighter-rouge&quot;&gt;var = [1,2,3]&lt;/code&gt;, então &lt;code class=&quot;highlighter-rouge&quot;&gt;push!(var,4)&lt;/code&gt; tem como resultado &lt;code class=&quot;highlighter-rouge&quot;&gt;[1,2,3,4]&lt;/code&gt;. Sendo assim estamos a somar os dois últimos valores de &lt;code class=&quot;highlighter-rouge&quot;&gt;fib&lt;/code&gt; e a adicionar o resultado a &lt;code class=&quot;highlighter-rouge&quot;&gt;fib&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTA:&lt;/strong&gt; Para quem está familiarizado com &lt;em&gt;MatLab&lt;/em&gt; e/ou &lt;em&gt;Python&lt;/em&gt;, &lt;em&gt;Julia&lt;/em&gt; tem uma pequena mas significativa diferença, quando se define um vetor ele vem em modo coluna e não em modo linha. Em &lt;em&gt;MatLab&lt;/em&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;[1,2,3] == [1 2 3]&lt;/code&gt;, mas em &lt;em&gt;Julia&lt;/em&gt; é diferente, porque o primeiro é uma coluna e o segundo é uma linha.&lt;/p&gt;

&lt;p&gt;Podemos também resolver este problema com um ciclo &lt;em&gt;for&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-julia highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;x&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;push!&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Usar vetores é uma arma muito poderosa, por isso sempre que possam utilizem, se acharem que for útil, obviamente.&lt;/p&gt;

&lt;h2 id=&quot;funções&quot;&gt;Funções&lt;/h2&gt;

&lt;p&gt;Este é o último capítulo antes de passarmos aos scripts, e que capítulo é este… Tudo é feito através de funções, funções são os que nos permitem reutilizar código, escrever algo uma vez e nunca mais precisar tocar nele, simplesmente enviar novos argumentos para dentro dela e ter diferentes respostas.&lt;/p&gt;

&lt;p&gt;No último exemplo dado, se eu quisesse experimentar o mesmo código várias vezes, com diferentes números de ciclos, teria de copiar, colar no REPL e mudar &lt;code class=&quot;highlighter-rouge&quot;&gt;for i = 1:5&lt;/code&gt; para &lt;code class=&quot;highlighter-rouge&quot;&gt;for i = 1:random_number&lt;/code&gt;, e isso é tedioso e consome demasiado tempo. Se colocássemos esse código numa função seria tudo mais simples! Vamos ver:&lt;/p&gt;

&lt;div class=&quot;language-julia highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; fibonacci&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;x&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;push!&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;x&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;x&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Aqui temos várias coisas para detalhar:&lt;/p&gt;

&lt;p&gt;Na linha 1, em &lt;code class=&quot;highlighter-rouge&quot;&gt;fibonacci(n)&lt;/code&gt; definimos o nome da função (fibonacci) e o nome dos argumentos necessários passar à função para ela fazer o seu trabalho (neste caso é só necessário um, mas se fossem precisos mais bastava separá-los por vírgulas, por exemplo &lt;code class=&quot;highlighter-rouge&quot;&gt;function fibonacci(arg1,arg2,arg3) end&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Na linha 6, a sintaxe &lt;code class=&quot;highlighter-rouge&quot;&gt;return fib&lt;/code&gt; significa que a função, depois de fazer os cálculos, vai-nos devolver o vetor &lt;code class=&quot;highlighter-rouge&quot;&gt;fib&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Neste caso, se quisermos fazer cinco cálculos, como nos exemplos anteriores, basta escrever no REPL &lt;code class=&quot;highlighter-rouge&quot;&gt;fibonacci(5)&lt;/code&gt; e o mesmo resultado aparecer-vos-á.&lt;/p&gt;

&lt;p&gt;Até agora nós temos descartado os primeiros dois valores da sequência, por exemplo, se queremos determinar cinco valores, na realidade estamos a determinar sete, visto que os dois primeiros são dados. Imaginando que o nosso objetivo é obter exatamente cinco valores da sequência, temos de alterar o exemplo anterior:&lt;/p&gt;

&lt;div class=&quot;language-julia highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; fibonacci&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;x&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elseif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;push!&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt; &lt;span class=&quot;x&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;x&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fib&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Esta já é uma função mais complexa, onde está implementado tudo o que demos até agora, ciclos, condições, vetores e funções.&lt;/p&gt;</content><author><name>Tiago Santos</name></author><summary type="html">Documentação oficial : https://docs.julialang.org/en/v0.6.4/</summary></entry></feed>